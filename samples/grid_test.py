'''
Main test for bonds` physics. Demonstrates the interaction of connected
ice elements with frozen joints. Also shows the way to draw total stress,
applied to each element.
'''

import subprocess
import os
import math
import sys
import datetime
import mathutils
import numpy

import siku
from   siku import polygon
from   siku import element
from   siku import material
from   siku import geocoords
from   siku import regrid
from   siku import gmt_Plotter
GMT_Plotter = gmt_Plotter.GMT_Plotter
from   siku import poly_voronoi
PolyVor = poly_voronoi.PolyVor
from   siku import h5load
hload = h5load.Loader

from   siku import wnd
from   siku import noisy_grid as NG
from   siku import color_works as cworks

# ---------------------------------------------------------------------
##
##import standard_callbacks as scb
##scb.siku = siku

def main():

    # ---------------------------------------------------------------------
    # Define material
    # ---------------------------------------------------------------------

    ice = material.Material()       # default ice values, 10 thicknesses
    ice.name = 'ice'                # prefer to use our own name instead
                                    # of default
                            
    ice.rho = [50.]*10 # lower density for lower inertia (faster movement)
    ice.E = 4e5 #for now - just some value for nice pictures
    
    siku.materials.append( ice )    # list of all materials

    # table of material names for convenience
    matnames = {
        'ice': 0,
    }

    # ---------------------------------------------------------------------
    # date/time settings
    # ---------------------------------------------------------------------
    
    hour = datetime.timedelta ( hours = 1 )

    siku.time.start    = datetime.datetime  ( 2014, 1, 1, 00, 00, 00 )
    siku.time.finish   = siku.time.start + 24 * hour

    siku.time.dt       = (siku.time.finish - siku.time.start) / 3600
    siku.time.dts      = datetime.timedelta ( seconds = 600 )
       
    # ---------------------------------------------------------------------
    # elements
    # ---------------------------------------------------------------------
    
    coords = []
    siku.elements = []
    n_filled = 0

    ## custom testing polygons for caribbeans # lon, lat convention

    # dimensions of sample grids
    x = 5
    y = 2

    # multiplicity of different samples
    NN = [ 1, 2, 4, 8 ]

    # actual sizes (in number of elements)
    nx = [ x*i for i in NN ]
    ny = [ y*i for i in NN ]

    # handlers
    left_inds = []
    right_inds = []
    left_gi = {}
    right_gi = {}
    
    ### grids representing body samples (generated by "noisy_grid" module)
    for i in range( len( NN ) ):
        cds, links = NG.generate_plus( \
            252.0+i*20.0, -2.0, 262.0+i*20.0, 2.0, nx[i], ny[i], 0., 0. )

        coords = coords + cds
        n_filled += nx[i]*ny[i]

    ### handles to apply the force
    for i in range( len( NN ) ):
        cds, links = NG.generate_plus( 252.0+i*20.0-10.0/nx[i], \
                        -2.0, 252.0+i*20.0, 2.0, 1, ny[i], 0., 0. )

        coords = coords + cds
        t = [ n_filled+j for j in range(ny[i]) ]
        left_inds = left_inds + t
        for j in t:  left_gi[j] = i
        n_filled += ny[i]

        cds, links = NG.generate_plus( 262.0+i*20.0, -2.0, \
                        262.0+i*20.0+10.0/nx[i], 2.0, 1, ny[i], 0., 0. )            

        coords = coords + cds
        t = [ n_filled+j for j in range(ny[i]) ]
        right_inds = right_inds + t
        for j in t:  right_gi[j] = i 
        n_filled += ny[i]

    #local data (for this particular test)
    siku.local.NN = NN
    siku.local.nx = nx
    siku.local.ny = ny
    siku.local.right_inds = right_inds
    siku.local.left_inds = left_inds
    siku.local.right_gi = right_gi
    siku.local.left_gi = left_gi

    # --- same old elements initialization

    gh = [ 0.2, 0.2, 0.4, 0.2, 0.0, 
           0.0, 0.0, 0.0, 0.0, 0.0 ]
    ### Initializing elements with polygon vertices
    for c in coords:
        siku.P.update( c )
     
        E = element.Element( polygon = siku.P, imat = matnames['ice'] )
        E.monitor = "drift_monitor"
        E.set_gh( gh, ice )
        
        siku.elements.append( E )

    # ---------------------------------------------------------------------
    #  Monitor function for the polygon
    # ---------------------------------------------------------------------

    ## Plotter initialization
    siku.plotter = GMT_Plotter( 'grid_config.py' )

    ### period of picturing
    siku.diagnostics.monitor_period = 60
    siku.drift_monitor = drift_monitor

    # ---------------------------------------------------------------------
    #  Physical constants
    # ---------------------------------------------------------------------

    siku.settings.phys_consts['windage'] = 0        # No desipation
    siku.settings.phys_consts['anchority'] = 0      # sources.
    siku.settings.phys_consts['fastency'] = 0.25    # Low borders fastency.
    siku.settings.phys_consts['etha'] = 0.01        # Pretty low viscosity.
    siku.settings.phys_consts['tensility'] = 1      # High tensility of bounds.
    
    # ------------------------- speed settings ----------------------------
 
    for i in left_inds:
        siku.elements[i].flag_state = element.Element.f_static

#### This could be uncommented to apply force rather than displacement velocity
##    siku.settings.manual_inds = right_inds
##    amo = len(right_inds)
##    F = 2000.0
##    siku.settings.manual_forces = [ (F/amo, -F/amo, 0.0) \
##                                    #-(i/nx)*1.0, -0.2*(i/ny/nx))
##                                    for i in right_inds ]

#### Applying external forces as fixed-velocity displacement (some kind of
#### infinite mass press). 
    for i in right_inds:
        
        siku.elements[i].velo = (3.0, 0.0, 0.0)     # tear 
##        siku.elements[i].velo = (-3.0, 0.0, 0.0)    # compression
##        siku.elements[i].velo = (0.0, -3.0, 0.0)    # slide
##        siku.elements[i].velo = (-3.0, -3.0, 0.0)   # wring
        
        siku.elements[i].flag_state = element.Element.f_steady

    # ---------------------------------------------------------------------
    #  Callback flag-mask generator
    # ---------------------------------------------------------------------

    siku.callback.pretimestep = pretimestep
    siku.callback.aftertimestep = aftertimestep
    siku.callback.conclusions = conclusions
    siku.callback.initializations = initializations


    return 0

# --------------------------------------------------------------------------

import errno
def mkdr( path ):
    '''Simple utility for creating subdirs'''
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
    return

def initializations( siku, t ):
    subprocess.call(["gmtset", "PS_MEDIA=Custom_72cx17.5c"]) #24_20

    mkdr( './forces' )
    siku.local.fces = []
    for i in range( len( siku.local.NN ) ):
        siku.local.fces.append( open( './forces/group' + str(i) + '.txt', 'w' ) )

    pass        

# --------------------------------------------------------------------------

def conclusions( siku, t ):
    
    print('creating .gif')
    subprocess.call( "convert -density 100 -delay 10 _GT*.eps GT.gif", \
                     shell=True )

    [ i.close() for i in siku.local.fces ]
    pass

# --------------------------------------------------------------------------

def pretimestep( t, n, ns ):
    status = siku.MASK['NONE']
    siku.diagnostics.step_count = n

    print("\r Step: " + str(n) + "\t", end = "", flush=True)

    siku.local.poly_f = open( 'Polygons.txt', 'w' )

    #accumulated force vector and stress
    siku.local.FF = [ mathutils.Vector( (0.0,0.0,0.0) )\
                      for i in siku.local.NN ]
    siku.local.ff = [ 0 for i in siku.local.NN ]

    return status

# --------------------------------------------------------------------------

def aftertimestep( t, n, ns ):
    siku.local.poly_f.close()

    if siku.diagnostics.step_count == 0 or \
       (siku.diagnostics.step_count+1) % siku.diagnostics.monitor_period == 0:
        pic_name = '_GT%03d.eps' % \
            (siku.diagnostics.step_count / siku.diagnostics.monitor_period)
        print('drawing ' + str( pic_name ) )

        siku.plotter.plot( pic_name )

#### Logging forces: this section dumps total forces applied to rightmost
#### column of each sample group. The result could be plotted or used for
#### some external analysis. For example with the sample script 'grid_plot.sh'
#### by calling it like "gnuplot grid_plot.sh" from the directory '/forces'
    for i in range( len( siku.local.FF ) ):
        f = siku.local.FF[ i ]
        s = siku.local.ff[ i ]
        t = f.length
        siku.local.fces[i].write( \
            str(n) + '\t' + str(s) + '\t' + str(t) + '\t' + \
            str(f[0]) + '\t' + str(f[1]) + '\t' + str(f[2]) + '\n' )

    return 0

# --------------------------------------------------------------------------

def drift_monitor( t, n, Q, Ps, st, index, ID, W, F, N, ss, \
                   m, I, i, A, a_f, w_f ):
    # create actual quaternion
    q = mathutils.Quaternion( Q )
    C = mathutils.Vector( (0,0,1) )

    # get latitude and longitude of center of mass (0,0,1)
    R = q.to_matrix()
    c = R * C

    s = -0.5*(ss[0] + ss[1])

    ## Forces monitor
    if index in siku.local.right_gi:
        siku.local.FF[ siku.local.right_gi[ index ] ] += \
                       mathutils.Vector( F )
        siku.local.ff[ siku.local.right_gi[ index ] ] += \
                       mathutils.Vector( F ).length

    # appending vertices to plotting list
    if siku.diagnostics.step_count == 0 or \
       (siku.diagnostics.step_count+1) % siku.diagnostics.monitor_period == 0:
        Pglob = [ R*mathutils.Vector( p ) for p in Ps ]
        vert = [ geocoords.lonlat_deg(mathutils.Vector( p ) ) for p in Pglob ]

        col1 = (255, 128, 127) #light red
        col2 = (128, 127, 255) #light blue
        col = cworks.gmt_color_hsv_scale( col2, col1, s, 1e5 )

        poly = siku.local.poly_f

        if st & element.Element.f_special:
            poly.write( '> -Gpink -W0.4p,'+col+' \n' )
        elif st & element.Element.f_static:
            poly.write( '> -G'+ col +' -W0.2p,black \n' )
        elif st & element.Element.f_steady:
            poly.write( '> -G'+ col +' -W0.2p,white \n' )
        else:
            poly.write( '> -G'+ col +' -W0.1p,'+ col +' \n' ) 
            
        for v in vert:
            poly.write( str( geocoords.norm_lon(v[0]) )+'\t'+ \
                        str( v[1] )+'\n' )

    return

# ---------------------------------------------------------------------
# Calling main function at the end
# ---------------------------------------------------------------------

siku.main = main()

if __name__ == '__main__':
    sys.exit( siku.main )
